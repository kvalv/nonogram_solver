import numpy as np
import itertools
import copy

from node import Node
import segments as sgm
from a_star import A_Star
from exception import InfeasibleStateException


class Nonogram_Solver(A_Star):

    def __init__(self, heuristic_fun, n_cols, n_rows, col_lengths, row_lengths, window=None):
        self.n_rows, self.n_cols = n_rows, n_cols
        self.col_lengths, self.row_lengths = col_lengths, row_lengths
        super().__init__(heuristic_fun, window)

    def generate_children(self, parent):
        """
        step 1: find all critical cell of row. this is found by finding 'common_indices'
        step 2: filter out all columns based on these critical cells.
        step 3: find all critical cell of column. this is found by finding 'common_indices'
        step 4: filter out all columns based on these critical cells.
        step 5: for each possible candidate in all rows / columns -- enforce it to single
        """

        rows, cols = parent.state
        def make_node(from_state, parent):
            node = Node(from_state)
            # self._attach_and_eval(node, parent)
            return node
            



        # step 1, 2, 3, 4
        column_size = self.n_rows
        row_size = self.n_cols
        try:
            rows_prime, cols_prime = sgm.enforce_cell_constraints(rows, cols, column_size, row_size)
        except InfeasibleStateException:
            # import pdb; pdb.set_trace()
            import pdb; pdb.set_trace()
            print('shouldnt occur..')
            pass
            raise StopIteration 
        rows, cols = rows_prime, cols_prime


        # filtering step -- reduce number of children generated by choosing
        # those with bottom 25% length
        def find_p_least_populated_line(lines, percentile, constant=3):
            lengths = np.array([len(e) for e in lines])
            if percentile == 100:
                return np.array([_ for _ in range(len(lines))])

            # ignore the 1's when calculating thresh_len
            without_ones = [e for e in lengths if e != 1]
            thresh_len = np.int64(np.percentile(without_ones, percentile)) + constant
            retval = np.where(np.logical_and(lengths > 1, lengths < thresh_len))[0]
            # import pdb; pdb.set_trace()
            return retval

        row_indices = find_p_least_populated_line(rows, 100)
        col_indices = find_p_least_populated_line(cols, 100)

        if len(row_indices) < 5 or len(col_indices) < 5:
            # too strong filtering -- revert!
            row_indices = find_p_least_populated_line(rows, 100)
            col_indices = find_p_least_populated_line(cols, 100)

        # step 5
        for idx, row_candidates in enumerate(rows):
            if idx not in row_indices:
                continue
            if len(row_candidates) == 1:
                continue

            for row in row_candidates:

                rows_with_assumption = copy.deepcopy(rows)
                rows_with_assumption[idx] = np.tile(row, [1, 1])
                try:
                    x,y = sgm.enforce_cell_constraints(rows_with_assumption, cols, column_size, row_size)
                    try:
                        x,y = sgm.enforce_cell_constraints(x, y, column_size, row_size)
                    except:
                        print('got except in row')
                        # import pdb; pdb.set_trace()
                    N = make_node([x, y], parent)
                    # N = make_node([x,y], parent, len(row_candidates))
                    yield N
                except InfeasibleStateException:
                    pass

        for idx, col_candidates in enumerate(cols):
            if idx not in col_indices:
                continue
            if len(col_candidates) == 1:
                continue

            for col in col_candidates:
                cols_with_assumption = copy.deepcopy(cols)
                _col_candidates = col_candidates
                cool = col
                cols_with_assumption[idx] = np.tile(col, [1, 1])
                try:
                    C = copy.deepcopy(cols)
                    cool = col
                    _col_candidates = col_candidates
                    x,y = sgm.enforce_cell_constraints(rows, cols_with_assumption, column_size, row_size)
                    try:
                        x,y = sgm.enforce_cell_constraints(x, y, column_size, row_size)
                    except:
                        print('got except in col')
                        # import pdb; pdb.set_trace()
                    N = make_node([x, y], parent)
                    # N = make_node([x,y], parent, len(col_candidates))
                    yield N
                except InfeasibleStateException:
                    pass



        # raise StopIteration

    def cost_fun(self, parent, child):
        return 0

    def goal_fun(self, node):
        rows, cols = node.state

        retval = np.all([len(each) == 1 for each in np.append(rows, cols)])
        return retval

    def generate_initial_node(self):
        cols = np.array([list(sgm.generate_segments_by_constraints(l, self.n_rows)) for l in self.col_lengths])
        rows = np.array([list(sgm.generate_segments_by_constraints(l, self.n_cols)) for l in self.row_lengths])

        state = rows, cols
        node = self._make_initial_node(state)
        node.info = 0
        return node
